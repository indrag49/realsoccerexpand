---
title: Convex Hulls, Delaunay Triangulations and Voronoi Diagrams
author: Indranil Ghosh
date: '2021-04-30'
slug: computational-geometry
categories: ["Python", "visualization", "Computational Geometry", "spatial algorithms"]
tags: ["statsbomb api", "scipy.spatial", "scipy", "sdpatial algorithms"]
subtitle: ''
summary: ''
authors: []
lastmod: '2021-04-30T10:46:23+05:30'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

In our [last tutorial](https://realsoccerexpand.netlify.app/post/pass-network-analysis/), we studied how to visualize a pass network for the teams from a particular match and how to analyse the networks using knowledge from complex network analysis literature. In this tutorial we will learn how to implement ideas from computational geometry on football spatial event or tracking data and generate important visualizations and analyses. This post is highly influenced by the concepts discussed in the second chapter *How Slime Moulds Built Barcelona* from the book [**Soccermatics**](https://www.amazon.in/Soccermatics-Mathematical-Adventures-Beautiful-Bloomsbury-ebook/dp/B01AIB7YKE).

First we will study how to develop a *convex hull* around those points (locations denoted by x- and y- coordinates) from where a player had made a pass or had taken a shot in a particular game. Mathematically, if these points are contained in a set **`X`** then the *convex hull* is the smallest convex set that contains **`X`**. This will help us get an idea about the optimal field coverage of a player during the match. Let us see how a convex hull for a set of points looks like:

![](convexhull.png)
This figure has been adapted from the [wikipedia article](https://en.wikipedia.org/wiki/Convex_hull#:~:text=In%20mathematics%2C%20the%20convex%20hull%20or%20convex%20envelope,is%20the%20smallest%20convex%20set%20that%20contains%20X.) on *convex hulls*.

Before we start with our data collection and analysis we need to download the [`scipy`](https://www.scipy.org/) package which provides us with a collection of modules for working on scientific computation with Python.
Let us `pip` install the package:

```{python eval=FALSE}
pip install scipy
```

We will first import all the packages that we need in this tutorial:

```{python}
from statsbombpy import sb # statsbomb api
import matplotlib.pyplot as plt # matplotlib for plotting
from mplsoccer.pitch import Pitch # for drawing the football pitch
import seaborn as sns # seaborn for plotting useful statistical graphs
import numpy as np # numerical python package
import pandas as pd # pandas for manipulating and analysing data
import networkx as nx # package for complex network analysis
```

Further, for this post, we need to use the `scipy.spatial` module that allows us to work with spatial algorithms and data structures. As we are going to work with *convex hulls* first, let us import the `ConvexHull` classes from `scipy.spatial`: 

```{python}
from scipy.spatial import ConvexHull
```

Next, we will collect the event data from a particular match and filter the data in such a way that the event `type` will be set to `Pass` or `Shot`, fetching us all the data for pass and shot events. 

```{python}
comp = sb.competitions()
print(comp.to_markdown())
```

Next, let us decide on a `competition_id` and a `season_id` to extract matches from a particular season and competition:

```{python}
mat = sb.matches(competition_id = 11, season_id = 1)
print(mat.to_markdown())
```

So, we have extracted the matches from 2017-18 La Liga season. Now let us decide on a particular match to extract the event data from:

```{python}
events = sb.events(match_id = 9609)
print(events.head(10).to_markdown())
print(events.tail(10).to_markdown())
```

We have extracted the event data from the `Barcelona` vs. `Eibar` match, which `Barcelona` won *6-1* at home (*Camp Nou*). Interesting!

Let us now look into the column names of `events`, such that we can only extract appropriate columns for visualizing and analyzing our convex hulls.

```{python}
print(events.columns)
```

Now let us pick the important columns from the `events` dataset:

```{python}
events_hull = events[['team', 'location', 'type', 'player']]
print(events_hull.head(10).to_markdown())
```

Seems like we only need four columns for now. As we are only focusing on pass and shot events, we will first filter the dataset by setting `type` to `Pass` or `Shot`.

```{python}
events_hull = events_hull[(events_hull['type'] == 'Pass') | (events_hull['type'] == 'Shot')].reset_index()
print(events_hull.head(10).to_markdown())
```

Then, we will split the `location` column into `location_x` and `location_y` columns:

```{python}
Loc = events_hull['location']
Loc = pd.DataFrame(Loc.to_list(), columns=['location_x', 'location_y'])
events_hull['location_x'] = Loc['location_x']
events_hull['location_y'] = Loc['location_y']
print(events_hull.head(10).to_markdown())
```

we can discard the `location` column:

```{python}
events_hull = events_hull[['team', 'type', 'player', 'location_x', 'location_y']]
```

We will next split the data into two datasets, one for `Barcelona` and the other for `Eibar`:

```{python}
events_hull_Barca = events_hull[events_hull['team'] == 'Barcelona'].reset_index()
events_hull_Eibar = events_hull[events_hull['team'] == 'Eibar'].reset_index()
```

Let us look into the first 10 rows of these datasets:

```{python}
print(events_hull_Barca.head(10).to_markdown())
print(events_hull_Eibar.head(10).to_markdown())
```

Next, we will list down the name of the players from both the teams:

```{python}
players_Barca = events_hull_Barca.player.unique()
players_Eibar = events_hull_Eibar.player.unique()
print(players_Barca)
print(players_Eibar)
```

First we will focus on computing and visualizing the convex hull for a particular player. What can be a better way to pay respect ðŸ™Œ ðŸ™Œ  to one of the greatest midfielders of all time `'AndrÃ©s Iniesta LujÃ¡n'` than picking him up for the analysis? 

We will now extract the event data for `Iniesta` from `events_hull_Barca`.

```{python}
events_hull_iniesta = events_hull_Barca[events_hull_Barca['player'] == 'AndrÃ©s Iniesta LujÃ¡n']
print(events_hull_iniesta.to_markdown())
```

Before computing and visualizing the convex hull, it is a good practice to discard the outliers from the datasets. A common method that researchers use is the [*Inter Quartile Range*](https://en.wikipedia.org/wiki/Interquartile_range). We will find the inter quartile ranges for the columns `location_x` and `location_y` from `events_hull_iniesta` and then compute the upper and lower bounds of the data. Any points lying beyond these bounds, i.e any point lying above the lower bound and any point lying below the upper bound, are decided to be *outliers* and are discarded. We use box plots and whisker plots to visualize the interquartile range for the datapoints:  

```{python results=FALSE}
e_box = pd.DataFrame(data = events_hull_iniesta, columns = ["location_x", "location_y"])
boxplot = sns.boxplot(x = "variable", y ="value", data=pd.melt(e_box), order = ["location_x", "location_y"])
boxplot = sns.stripplot(x = "variable", y = "value", data = pd.melt(e_box), marker="o", color="red", order = ["location_x", "location_y"])
boxplot.axes.set_title("Boxplot for Iniesta's location conditions")
plt.show()
```

We will next compute the quartiles, the inter quartile range and the minimum and maximum values:

```{python}
Q1 = np.percentile(events_hull_iniesta['location_x'], 25, interpolation='midpoint')
Q3 = np.percentile(events_hull_iniesta['location_x'], 75, interpolation='midpoint')
IQR_x = Q3 - Q1

minimum_x = Q1 - 1.5*IQR_x
maximum_x = Q3 + 1.5*IQR_x
Q1, Q3, IQR_x, minimum_x, maximum_x

```

```{python}
Q1 = np.percentile(events_hull_iniesta['location_y'], 25, interpolation='midpoint')
Q3 = np.percentile(events_hull_iniesta['location_y'], 75, interpolation='midpoint')
IQR_y = Q3 - Q1

minimum_y = Q1 - 1.5*IQR_y
maximum_y = Q3 + 1.5*IQR_y
Q1, Q3, IQR_y, minimum_y, maximum_y
```

```{python}
upper = np.where((events_hull_iniesta['location_x'] >= maximum_x) & (events_hull_iniesta['location_y'] >= maximum_y))
lower = np.where((events_hull_iniesta['location_x'] <= minimum_x) & (events_hull_iniesta['location_y'] <= minimum_y))
```

Finally, we will drop the outliers if present:

```{python results=FALSE}
events_hull_iniesta.drop(upper[0], inplace = True)
events_hull_iniesta.drop(lower[0], inplace = True)
```

Let us again print the top 10 rows of the `events_hull_iniesta` dataset:

```{python}
events_hull_iniesta = events_hull_iniesta.reset_index()
events_hull_iniesta = events_hull_iniesta[['team', 'type', 'player', 'location_x', 'location_y']]
print(events_hull_iniesta.to_markdown())
```

First we collect all the points from the two columns as a 2-D matrix. This comes in aid while drawing the convex hull.

```{python}
points_hull = events_hull_iniesta[['location_x', 'location_y']].values
print(points_hull)
```

Now, let us use the `ConvexHull()` function from `scipy.spatial`:

```{python}
convex_hull_iniesta = ConvexHull(events_hull_iniesta[['location_x', 'location_y']])
```

This *convex hull* is represented by the *vertices*, i.e the coordinate points that make the vertices of the convex hull and the *simplices*, i.e the stratight line in case of a 2-D plane that connects the *vertices* of the the *convex hull*. The `vertices` attribute consists of the indices of the points in `points_hull` that make up the convex hull, and the `simplices` attribute too consists of the indices of the points in `points_hull`. The `simplices` are a list of 1-D simplices of a particular length, representing line segments in 2-D. Let us print the indices:

```{python}
print(convex_hull_iniesta.vertices)
print(convex_hull_iniesta.simplices)
```

Now we have collected all the useful information and will visualize the convex hull on a football pitch:

```{python results=FALSE}
pitch = Pitch(pitch_color='black', line_color='white', goal_type='box', 
              constrained_layout=True, tight_layout=False)
fig, ax = pitch.draw()

plt.scatter(events_hull_iniesta.location_x, events_hull_iniesta.location_y, color='red')

for i in convex_hull_iniesta.simplices:
    plt.plot(points_hull[i, 0], points_hull[i, 1], 'white')
    plt.fill(points_hull[convex_hull_iniesta.vertices, 0], points_hull[convex_hull_iniesta.vertices, 1], c='white', alpha=0.1)

plt.title("Convex Hull for Iniesta's field coverage against Eibar")
```

So, we see that `Iniesta` mostly covered the left side of `Barcelona`'s attack on the field. That speaks a lot! Now let us go ahead and compute and visualize the convex hull for all the players in a team

```{python results=FALSE}
ccodes = ['#FAEBD7', '#66CDAA', '#E3CF57', '#8A2BE2', '#EE3B3B', '#66CD00', '#DC143C', '#FFB90F', '#A9A9A9', '#B23AEE', '#CD1076',
         '#8B6914', '#BFEFFF', '#EED2EE', '#C6E2FF', '#C67171']
         
fig, axes = plt.subplots(6, 3, figsize = (20, 25))
axes = axes.ravel()

for idx, p in enumerate(players_Barca):
    pitch = Pitch(pitch_color='black', line_color='white', goal_type='box', 
              constrained_layout=True, tight_layout=False)
    pitch.draw(axes[idx])
    xmin, xmax, ymin, ymax = pitch.extent
    
    axes[idx].xaxis.set_ticks([xmin, xmax])
    axes[idx].yaxis.set_ticks([ymin, ymax])
    axes[idx].tick_params(labelsize=15)
    axes[idx].set_title(p, fontsize=20, pad=8)
    
    Eh = events_hull_Barca[events_hull_Barca['player'] == p].reset_index()
    
    Q1 = np.percentile(Eh['location_x'], 25, interpolation='midpoint')
    Q3 = np.percentile(Eh['location_x'], 75, interpolation='midpoint')
    IQR_x = Q3 - Q1

    minimum_x = Q1 - 1.5*IQR_x
    maximum_x = Q3 + 1.5*IQR_x
    
    Q1 = np.percentile(Eh['location_y'], 25, interpolation='midpoint')
    Q3 = np.percentile(Eh['location_y'], 75, interpolation='midpoint')
    IQR_y = Q3 - Q1

    minimum_y = Q1 - 1.5*IQR_y
    maximum_y = Q3 + 1.5*IQR_y
    
    upper = np.where((Eh['location_x'] >= maximum_x) & (Eh['location_y'] >= maximum_y))
    lower = np.where((Eh['location_x'] <= minimum_x) & (Eh['location_y'] <= minimum_y))
    
    Eh.drop(upper[0], inplace = True)
    Eh.drop(lower[0], inplace = True)
    
    points_Barca = Eh[['location_x', 'location_y']].values
    convex_hull_Barca = ConvexHull(Eh[['location_x', 'location_y']])
    
    axes[idx].scatter(Eh.location_x, Eh.location_y, color='red')
    
    for i in convex_hull_Barca.simplices:
            axes[idx].plot(points_Barca[i, 0], points_Barca[i, 1], 'white')
            axes[idx].fill(points_Barca[convex_hull_Barca.vertices, 0], points_Barca[convex_hull_Barca.vertices, 1], c=ccodes[idx], alpha=0.1)
            
title = fig.suptitle("Convex Hulls for Barcelona players' field coverage vs Eibar [La Liga 2017-18]", fontsize=33)

for j in range(len(players_Barca)-18, 0):
    axes[j].remove()
plt.show()
```

Now, we will compute for `Eibar`'s team players:

```{python results = FALSE}
ccodes = ['#FAEBD7', '#66CDAA', '#E3CF57', '#8A2BE2', '#EE3B3B', '#66CD00', '#DC143C', '#FFB90F', '#A9A9A9', '#B23AEE', '#CD1076',
         '#8B6914', '#BFEFFF', '#EED2EE', '#C6E2FF', '#C67171']
         
fig, axes = plt.subplots(6, 3, figsize = (20, 25))
axes = axes.ravel()

for idx, p in enumerate(players_Eibar):
    pitch = Pitch(pitch_color='black', line_color='white', goal_type='box', 
              constrained_layout=True, tight_layout=False)
    pitch.draw(axes[idx])
    xmin, xmax, ymin, ymax = pitch.extent
    
    axes[idx].xaxis.set_ticks([xmin, xmax])
    axes[idx].yaxis.set_ticks([ymin, ymax])
    axes[idx].tick_params(labelsize=15)
    axes[idx].set_title(p, fontsize=20, pad=8)
    
    Eh = events_hull_Eibar[events_hull_Eibar['player'] == p].reset_index()
    Eh['location_x'] = 120 - Eh['location_x']
    
    Q1 = np.percentile(Eh['location_x'], 25, interpolation='midpoint')
    Q3 = np.percentile(Eh['location_x'], 75, interpolation='midpoint')
    IQR_x = Q3 - Q1

    minimum_x = Q1 - 1.5*IQR_x
    maximum_x = Q3 + 1.5*IQR_x
    
    Q1 = np.percentile(Eh['location_y'], 25, interpolation='midpoint')
    Q3 = np.percentile(Eh['location_y'], 75, interpolation='midpoint')
    IQR_y = Q3 - Q1

    minimum_y = Q1 - 1.5*IQR_y
    maximum_y = Q3 + 1.5*IQR_y
    
    upper = np.where((Eh['location_x'] >= maximum_x) & (Eh['location_y'] >= maximum_y))
    lower = np.where((Eh['location_x'] <= minimum_x) & (Eh['location_y'] <= minimum_y))
    
    Eh.drop(upper[0], inplace = True)
    Eh.drop(lower[0], inplace = True)
    
    points_Eibar = Eh[['location_x', 'location_y']].values
    convex_hull_Eibar = ConvexHull(Eh[['location_x', 'location_y']])
    
    axes[idx].scatter(Eh.location_x, Eh.location_y, color='red')
    
    for i in convex_hull_Eibar.simplices:
            axes[idx].plot(points_Eibar[i, 0], points_Eibar[i, 1], 'white')
            axes[idx].fill(points_Eibar[convex_hull_Eibar.vertices, 0], points_Eibar[convex_hull_Eibar.vertices, 1], c=ccodes[idx], alpha=0.1)
            
title = fig.suptitle("Convex Hulls for Eiber players' field coverage vs Barcelona [La Liga 2017-18]", fontsize=33)

for j in range(len(players_Eibar)-18, 0):
    axes[j].remove()
plt.show()
```

So, we have been able to compute and visualize the convex hulls for players from a particular game. Next, we will try to understand how to get tracking data from a particular game using `statsbomb` api. We need tracking data to compute *Delaunay triangulations* and *Voronoi diagrams*.


**This post is still under construction**